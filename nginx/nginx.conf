worker_processes 4;

    
events {
    worker_connections 1024;
}

http {
    resolver 127.0.0.11 ipv6=off;

    # Define shared memory zones
    lua_shared_dict rate_limit_dict 10m;
    lua_shared_dict my_locks 1m;
    lua_shared_dict my_cache 10m;
    lua_socket_log_errors off;
    
    upstream webui {
        server webui:8080;
    }

    upstream auth {
        server auth:8080;
    }

    upstream recommender {
        server recommender:8080;
    }

    upstream persistence {
        server persistence:8080;
    }
    
    upstream image {
        server image:8080;
    }

    limit_req_zone $binary_remote_addr zone=mylimit:10m rate=83r/s;

    init_by_lua_block {
        ngx.log(ngx.INFO, "Initializing test data...")
        local shared_dict = ngx.shared.rate_limit_dict
        shared_dict:set("test_key:batch", 100)
        shared_dict:set("test_key:used", 20)
        ngx.log(ngx.INFO, "Test data initialized successfully")
    }

    init_worker_by_lua_block {
        local redis = require "resty.redis"
        local cjson = require "cjson"
        
        local function handle_steal_request()
            local redis_host = "redis" -- Set Redis host
            local redis_port = 6379         -- Set Redis port
            local steal_request_channel = "quota_steal_requests"
            local steal_response_channel = "quota_steal_responses:"
            local node_id = os.getenv("NODE_ID") or ngx.worker.pid() -- Set your unique node ID here
            local redis_timeout = 1000      -- Redis timeout in ms

            local red = redis:new()
            red:set_timeout(redis_timeout)
            
            local ok, err = red:connect(redis_host, redis_port)
            if not ok then
                ngx.log(ngx.ERR, "Failed to connect to Redis:", err)
                return
            end

            ok, err = red:subscribe(steal_request_channel)
            if not ok then
                ngx.log(ngx.ERR, "Failed to subscribe to channel:", err)
                return
            end

            while true do
                local res, err = red:read_reply()
                if res and res[1] == "message" then
                    local request = cjson.decode(res[3])
                    local shared_dict = ngx.shared.rate_limit_dict
                    
                    -- Check local quota
                    local batch_quota = shared_dict:get(request.redis_key .. ":batch") or 0
                    local batch_used = shared_dict:get(request.redis_key .. ":used") or 0
                    local available = batch_quota - batch_used

                    if available > 1 then
                        local share_amount = math.floor(available / 2)
                        
                        -- Reduce local quota
                        shared_dict:set(request.redis_key .. ":batch", batch_quota - share_amount)
                        
                        -- Send response
                        local resp_red = redis:new()
                        resp_red:connect(redis_host, redis_port)
                        local response = {
                            donor_id = node_id,
                            quota = share_amount
                        }
                        resp_red:publish(steal_response_channel .. request.requester_id, 
                                         cjson.encode(response))
                        resp_red:set_keepalive(10000, 10)
                    end
                end
            end
        end

        if ngx.worker.id() == 0 then
            ngx.timer.at(0, handle_steal_request)
        end
    }

    #redis-cli MONITOR
    #redis-cli PUBLISH quota_steal_requests '{"requester_id":"test","redis_key":"test_key","timestamp":1234567890}'

    
    server {
        listen 8080;
        
        location / {
            default_type 'text/plain';
            proxy_pass http://webui;
        }

        location /tools.descartes.teastore.auth/rest {
            set $service_name "auth";
            access_by_lua_file lua_scripts/algorithm.lua;
            proxy_pass http://auth;
        }

        location /tools.descartes.teastore.recommender/rest {
            set $service_name "recommender";
            access_by_lua_file lua_scripts/algorithm.lua;
            proxy_pass http://recommender;
        }

        location /tools.descartes.teastore.persistence/rest {
            set $service_name "persistence";
            access_by_lua_file lua_scripts/algorithm.lua;
            proxy_pass http://persistence;
        }

        location /tools.descartes.teastore.image/rest {
            set $service_name "image";
            access_by_lua_file lua_scripts/algorithm.lua;
            proxy_pass http://image;
        }
    }
}
